{"_id": "/activity/7330df52-8b90-11e7-9241-3401663b8331", "uri": "/activity/7330df52-8b90-11e7-9241-3401663b8331", "publisher": null, "level": "principiante", "rights": "Attribution-ShareAlike 4.0 International", "description": "Definici\u00f3n de constructor con ejemplos en c#", "icon": "file", "author": "Mario Garc\u00eda Valdez", "tags": ["clase", "csharp", "frontpage"], "image_url": null, "title": "Constructores en C#", "type": "text", "external_url": "https://sfo2.digitaloceanspaces.com/evo/uno/autores/mario.jpg", "author_image": "https://sfo2.digitaloceanspaces.com/evo/uno/autores/mario.jpg", "content": "<p>\u00bfQu\u00e9 necesitamos para crear un nuevo objeto en los lenguajes orientados a objetos?</p>\n<p>Recordemos que los objetos son instancias de una clase, dicho de otra manera\nnecesitamos primero la clase que va a definir al tipo de objeto que desamos crear. </p>\n<p>Una vez que tenemos la clase, el proceso de crear un nuevo objeto a partir de ella\nlo podemos resumir en tres pasos:</p>\n<ol>\n<li>Necesitamos revisar que haya espacio suficiente en la memoria para almacenar\nel estado del objeto. Dependiendo del lenguaje y las opciones disponibles normalmente\nse almacenan los objetos en la memoria heap o pero a veces en el stack.</li>\n<li>Una vez que reservamos el espacio se crea el objeto y sabemos la direcci\u00f3n en la \nmemoria d\u00f3nde se almacen\u00f3.</li>\n<li>Por \u00faltimo debemos inicializar el estado del objeto. </li>\n</ol>\n<p>Los constructores realizan son m\u00e9todos especiales que incluimos en las clases, y los\nllamamos como parte de la instrucci\u00f3n para crear un objeto. En el caso de C# y otros\nlenguajes, los constructores reciben los valores iniciales del estado del objeto como \nargumentos y estos se asignan en el constructor. </p>\n<p>Veamos un ejemplo para la clase <code>Persona</code>:</p>\n<pre><code class=\"language-csharp\">// Clase Base\nclass Persona \n{ \n  // Propiedades\n  public int ID { get; set;}\n  public string Nombre { get; set;}\n}\n\n// Constructor por defecto. En caso de que una clase derivada no invoque el \n// constructor de la clase base explicitamente, este constructor se ejecutar\u00e1\n// implicitamente.\npublic Persona()\n{\n  ID = 0;\n  Nombre = &quot;Fulano de Tal&quot;;\n}\n\n// Constructor de instancia con los dos par\u00e1metros necesarios para\n// incializar el estado de un objeto.\npublic Persona( int ID, string nombre)\n{\n this.ID = ID // Ocupamos this por que la variable local del par\u00e1metro ID\n              // se llama igual que el miembro ID.\n Nombre = nombre;\n}\n\n// M\u00e9todo que imprime los datos de la persona \n// Este m\u00e9todo lo vamos a mejorar m\u00e1s adelante\npublic void ImprimePersona()\n{\n  Console.WriteLine($&quot;{ID} {Nombre}&quot;)\n}\n</code></pre>\n<p>En este ejemplo la clase tiene dos constructores:</p>\n<ol>\n<li>\n<p>El constructor <code>Persona()</code> sin argumentos. Este constructor siempre \ninicializa las propiedades o campos a un valor predeterminado. Por este motivo \na este constructor le llamamos el constructor por defecto. En el caso de C#,\nsi no especificamos ning\u00fan constructor para la clase, se crea un constructor \nimplicito sin argumentos el cual inicializa el estado a los valores predeterminados\nseg\u00fan el tipo de dato de los campos miembro. Por ejemplo, los enteros en cero,\nlas cadenas vacias, etc. En caso de que agregemos un constructor a nuestra\nclase el constructor por defecto implicito ya no se genera, si necesitamos\neste constructor debemos crearlo expl\u00edcitamente.</p>\n</li>\n<li>\n<p>El constructor <code>Persona( int ID, string nombre)</code>, en este caso, el constructor\nva a recibir como argumentos los valores iniciales de <code>ID</code> y <code>Nombre</code>. F\u00edjate\ncomo en el caso del argumento <code>ID</code> como se llama igual que la propiedad <code>ID</code>\nmiembro de la clase, se debe distinguir a la variable miembro con la referencia\n<code>this</code> al hacer la asignaci\u00f3n <code>this.ID = ID</code> de otro modo se estar\u00eda asignando\nel valor a la misma variable.</p>\n</li>\n</ol>\n<p>Como podemos observar en el c\u00f3digo, vemos que los constructores difieren \na los m\u00e9todos instancia en lo siguiente:</p>\n<ol>\n<li>No se debe especificar un tipo de retorno, ni siquiera <code>void</code>.</li>\n<li>No se heredan a otras clases.</li>\n<li>En C# el constructor debe llamarse igual que la clase. En otros lenguajes debe\ntener nombres especi\u00edficos, por ejemplo <code>constructor</code> en JavaScript o <code>__init__</code> en \nPython.</li>\n<li>En C# contamos con una sintaxis para ejecutar otros constructores dentro \ndel encabezado del constructor, utilizando las palabras reservadas <code>this</code> o <code>base</code>. \nEl caso de <code>base</code> lo veremos en el tema de herencia. </li>\n</ol>\n<blockquote>\n<p>En el siguiente ejemplo modificamos el constructor <code>Persona()</code> para llamar al \nconstructor con argumentos. Esto es un ejemplo de una buena pr\u00e1ctica, no repetir\nc\u00f3digo.</p>\n</blockquote>\n<pre><code class=\"language-csharp\">// Clase Base\nclass Persona \n{ \n  // Propiedades\n  public int ID { get; set;}\n  public string Nombre { get; set;}\n}\n\n// Constructor por defecto. En caso de que una clase derivada no invoque el \n// constructor de la clase base explicitamente, este constructor se ejecutar\u00e1\n// implicitamente.\npublic Persona():this(0, &quot;Fulano de Tal&quot;)\n{\n}\n\n// Constructor de instancia con los dos par\u00e1metros necesarios para\n// incializar el estado de un objeto.\npublic Persona( int ID, string nombre)\n{\n this.ID = ID // Ocupamos this por que la variable local del par\u00e1metro ID\n              // se llama igual que el miembro ID.\n Nombre = nombre;\n}\n\n// M\u00e9todo que imprime los datos de la persona \n// Este m\u00e9todo lo vamos a mejorar m\u00e1s adelante\npublic void ImprimePersona()\n{\n  Console.WriteLine($&quot;{ID} {Nombre}&quot;)\n}\n</code></pre>"}